# MySQL行锁、表锁、页锁、悲观锁、乐观锁、间隙锁

存储类型|行锁|表锁|页锁
---|---|---|---
MyISAM||√| 	 
BDB||√|√
InnoDB|√|√|

锁类型|开销|加锁速度|死锁|粒度|并发性能
---|---|---|---|---|---
[表锁](#表锁)|开销小|快|不死锁|粒度大|发生锁冲突概率高，并发度最低
[行锁](#行锁)|开销大|慢|死锁|粒度小|发生锁冲突的概率低，并发度高
[页锁](#页锁)|开销中|中|死锁|粒度中|并发度一般

# 表锁
* 表共享读锁（Table Read Lock）
* 表独占写锁（Table Write Lock）
---
# 行锁
锁类型|简称|description
---|---|---
共享锁(S)|读锁|若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A<br>其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁<br>这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改
排他锁(X)|写锁|若事务T对数据对象A加上X锁，事务T可以读A也可以修改A<br>其他事务不能再对A加任何锁，直到T释放A上的锁<br>这保证了其他事务在T释放A上的锁之前不能再读取和修改A<br>**InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁**
意向共享锁(IS)|事务在给一个数据行加共享锁前必须先取得该表的IS锁
意向排他锁(IX)|事务在给一个数据行加排他锁前必须先取得该表的IX锁
```
共享锁(S)：SELECT * 
          FROM table_name 
          WHERE ... 
          LOCK IN SHARE MODE。
排他锁(X)：SELECT * 
          FROM table_name 
          WHERE ... 
          FOR UPDATE。
```
#### **✧InnoDB行锁是通过给索引上的索引项加锁来实现的**
##### 这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。
##### InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
---
# 间隙锁（Next-Key锁）
### 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）
```
假设有一个只有101条数据的表
Select * from xxx where id > 100 for update;
是一个范围条件的检索，InnoDB不仅会对符合条件的id值为101的记录加锁，也会对id大于101（这些记录并不存在）的“间隙”加锁
```

