# MySQL行锁、表锁、页锁、悲观锁、乐观锁、间隙锁

存储类型|行锁|表锁|页锁
---|---|---|---
MyISAM||√| 	 
BDB||√|√
InnoDB|√|√|

锁类型|开销|加锁速度|死锁|粒度|并发性能
---|---|---|---|---|---
[表锁](#表锁)|开销小|快|不死锁|粒度大|发生锁冲突概率高，并发度最低
[行锁](#行锁)|开销大|慢|死锁|粒度小|发生锁冲突的概率低，并发度高
[页锁](#页锁)|开销中|中|死锁|粒度中|并发度一般

# 表锁
* 表共享读锁（Table Read Lock）
* 表独占写锁（Table Write Lock）
---
# 行锁
锁类型|简称|description
---|---|---
共享锁(S)|读锁|若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A<br>其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁<br>这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改
排他锁(X)|写锁|若事务T对数据对象A加上X锁，事务T可以读A也可以修改A<br>其他事务不能再对A加任何锁，直到T释放A上的锁<br>这保证了其他事务在T释放A上的锁之前不能再读取和修改A<br>**InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁**
意向共享锁(IS)|事务在给一个数据行加共享锁前必须先取得该表的IS锁
意向排他锁(IX)|事务在给一个数据行加排他锁前必须先取得该表的IX锁
```
共享锁(S)：SELECT * 
          FROM table_name 
          WHERE ... 
          LOCK IN SHARE MODE。
排他锁(X)：SELECT * 
          FROM table_name 
          WHERE ... 
          FOR UPDATE。
```
#### **✧InnoDB行锁是通过给索引上的索引项加锁来实现的**
##### 这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。
##### InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
---
# 乐观锁
```
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，
但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现
--------------------- 
# 版本号机制
假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。
    操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）
    在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）
    操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），
          提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 
    操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），
          但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，
          不满足 “ 当前最后更新的version与操作员第一次的版本号相等 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。
这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。
--------------------- 
# CAS算法
即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，
也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。
CAS算法涉及到三个操作数
    需要读写的内存值 V
    进行比较的值 A
    拟写入的新值 B
当且仅当V==A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作
（比较和替换是一个原子操作）
一般情况下是一个自旋操作，即不断的重试。
--------------------- 
乐观锁适用于多读的应用类型，这样可以提高吞吐量，
像数据库提供的类似于write_condition机制，其实都是提供的乐观锁
```
# 悲观锁
```
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，
这样别人想拿这个数据就会阻塞直到它拿到锁
（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁
```
---
# 间隙锁（Next-Key锁）
### 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）
```
假设有一个只有101条数据的表
Select * from xxx where id > 100 for update;
是一个范围条件的检索，InnoDB不仅会对符合条件的id值为101的记录加锁，也会对id大于101（这些记录并不存在）的“间隙”加锁
```
---
> 一篇好文:https://www.cnblogs.com/jpfss/p/8890250.html
