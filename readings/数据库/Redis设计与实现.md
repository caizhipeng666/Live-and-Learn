# Redis设计与实现
## Czp
---

章节 | 内容
:---: | :---:
[1](#简单动态字符串) | 字符串
[2](#链表) | 列表
[3](#字典) | 哈希表(字典)
[4](#跳跃表) | 指向其他结点指针
[5](#整数集合) | 整数集set
[6](#压缩列表) | 压缩列表
[7](#对象) | 对象

# 简单动态字符串
## SDS
---

1. 数据结构
   > free   → 未使用空间   
   > len   → 字符串长度   
   > buf   → 存储字符串内容   
2. 因为C字符串不记录自身长度,所以容易造成缓冲区溢出
   > 在修改C字符串时如果没有提前分配内存,因为分配空间不够,容易造成其他字符串意外被修改   

   > 每次修改需要重新分配内存 → SDS通过使用未使用空间free来进行空间预分配和惰性空间释放   
3. SDS在修改时会先检查len是否足够,如果不够,则拓展SDS的len和free为修改后的长度
4. 空间预分配:
   > 优化SDS字符串增长操作 → 在对SDS进行修改时同时修改len和free   
   
   > 此时buf长度就变为了len+free+1
   
   > 这样当下次增长操作来的时候,先判断free是否足够,如果足够直接就插入进去了(无需分配内存)
5. 惰性空间释放:
   > 优化SDS字符串缩短操作 → 不立即收回多出来的字节,而是存到free中
6. C字符串不能包含空字符,否则最先被程序读入的空字符将被误认为是字符串结尾,所以只能保留文本信息
7. Redis的所有SDS API都是以二进制的方式来处理SDS存放在buf数组里的数据,不做任何处理(二进制安全)

# 链表
---

1. 数据结构 → 表
   > *head   
   > *tail   
   > len   
   > *dup   (节点复制)   
   > *free   （节点释放）  
   > *match   (节点值对比)   
2. 数据结构 → 节点   
   > prev   
   > next   
   > *value   
3. 表头的prev和表尾的next指针指向NULL   
   (对链表的访问以NULL为终点)
4. 使用*void指针来保存节点值,并且可以通过dup、free、match三个属性为节点值设置类型特定函数   
   (所以链表可以保存不同类型的值)

# 字典
## 哈希键的底层实现
> Redis的数据库就是使用字典来作为底层实现的,对数据库的CRUD也是建立在对字典的操作上   
---

1. 数据结构 → 哈希表   
   > **table   → 哈希表数组   (其中每个元素都指向一个哈希节点)   
   > size   → 哈希表大小   
   > sizemask   → 哈希表大小掩码,用于计算索引值   
   > used   (复制)   → 已有节点数量   
2. 数据结构 → 哈希表节点
   > *key   → 键   
   > v   → 值   
   > *next   (可以将多个哈希值相同的键值对连在一起,以此解决键冲突)   
3. 数据结构 → 字典   
   > *type   → 类型特定函数   
   > *privdata   → 私有数据   
   > ht[2]   → 哈希表   
   > trehashinx   → rehash索引   
4. ht属性是个包含两个项的数组,每个项都是个哈希表   
   (一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用)   
5. hash = 哈希表的hashFunction(键)
6. index = hash(↑) & ht[x].sizemark

# 跳跃表
## 有序集合键/集群节点
---

1. 数据结构 → zskiplistNode表   
   > header   → 指向跳跃表头节点    
   > tail   → 跳跃表尾节点   
   > level   → 跳跃表深度   
   > length   → 存在节点值的节点数   
2. 数据结构 → 跳跃表节点   
   > score   → 分值   
   > *obj   → 对象   
   > zskiplistLevel   → 层(L1,L2,L3...)   
     (层数越多,访问其他节点的速度越快)

# 整数集合
---

1. 数据结构
   > encoding     
   > length      
   > contents[]   → 保存元素的数组   
2. 整数集合不支持降级操作,一旦对数组进行了升级,编码会一直保持升级后的状态

# 压缩列表
---

1. 当一个列表键只包含少量列表项,并且每个列表项要么是小整数值,要么是长度较短的字符串 → 压缩列表
2. 压缩列表是由一系列特殊编码的连续内存块组成的顺序数据结构
3. 每个压缩列表节点可以保存一个字节数组/一个整数组
4. 连锁更新 → 不断地对压缩列表执行空间重分配操作

# 对象
---

1. 
