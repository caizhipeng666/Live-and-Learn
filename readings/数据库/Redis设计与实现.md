# Redis设计与实现
## Czp
---

章节 | 内容
:---: | :---:
[1](#简单动态字符串) | 字符串
[2](#链表) | 列表
[3](#字典) | 哈希表(字典)
[4](#跳跃表) | 

# 简单动态字符串
## SDS
---

1. 数据结构
   > free   → 未使用空间   
   > len   → 字符串长度   
   > buf   → 存储字符串内容   
2. 因为C字符串不记录自身长度,所以容易造成缓冲区溢出
   > 在修改C字符串时如果没有提前分配内存,因为分配空间不够,容易造成其他字符串意外被修改   

   > 每次修改需要重新分配内存 → SDS通过使用未使用空间free来进行空间预分配和惰性空间释放   
3. SDS在修改时会先检查len是否足够,如果不够,则拓展SDS的len和free为修改后的长度
4. 空间预分配:
   > 优化SDS字符串增长操作 → 在对SDS进行修改时同时修改len和free   
   
   > 此时buf长度就变为了len+free+1
   
   > 这样当下次增长操作来的时候,先判断free是否足够,如果足够直接就插入进去了(无需分配内存)
5. 惰性空间释放:
   > 优化SDS字符串缩短操作 → 不立即收回多出来的字节,而是存到free中
6. C字符串不能包含空字符,否则最先被程序读入的空字符将被误认为是字符串结尾,所以只能保留文本信息
7. Redis的所有SDS API都是以二进制的方式来处理SDS存放在buf数组里的数据,不做任何处理(二进制安全)

# 链表
---

1. 数据结构 → 表
   > *head   
   > *tail   
   > len   
   > *dup   (节点复制)   
   > *free   （节点释放）  
   > *match   (节点值对比)   
2. 数据结构 → 节点   
   > prev   
   > next   
   > *value   
3. 表头的prev和表尾的next指针指向NULL   
   (对链表的访问以NULL为终点)
4. 使用*void指针来保存节点值,并且可以通过dup、free、match三个属性为节点值设置类型特定函数   
   (所以链表可以保存不同类型的值)

# 字典
## 哈希键的底层实现
> Redis的数据库就是使用字典来作为底层实现的,对数据库的CRUD也是建立在对字典的操作上   
---

1. 数据结构 → 哈希表   
   > **table   → 哈希表数组   (其中每个元素都指向一个哈希节点)   
   > size   → 哈希表大小   
   > sizemask   → 哈希表大小掩码,用于计算索引值   
   > used   (复制)   → 已有节点数量   
2. 数据结构 → 哈希表节点
   > *key   → 键   
   > v   → 值   
   > *next   (可以将多个哈希值相同的键值对连在一起,以此解决键冲突)   
3. 数据结构 → 字典   
   > *type   → 类型特定函数   
   > *privdata   → 私有数据   
   > ht[2]   → 哈希表   
4. ht属性是个包含两个项的数组,每个项都是个哈希表
   (一般情况下,字典只使用ht[0]哈希表,ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用)
