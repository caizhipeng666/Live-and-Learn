# 一次I/O
```
1.等待数据,将数据从网络/磁盘拷贝到系统kennel的缓冲区
2.将数据从kennel拷贝到进程中
```

# 五种I/O
```
1.阻塞I/O模型
老李去火车站买票，排队三天买到一张退票。
耗费：在车站吃喝拉撒睡 3天，其他事一件没干。

2.非阻塞I/O模型
老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。
耗费：往返车站6次，路上6小时，其他时间做了好多事。

3.I/O复用模型
   1.select/poll
   老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。
   耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次

   2.epoll
   老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。
   耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话

4.信号驱动I/O模型
老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。
耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话

5.异步I/O模型
老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。
耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话
```

# I/O多路复用与异步I/O
1. I/O多路复用
```
    锁住整个进程，不断轮询所有socket(套接字是不被block的),
    同时，kernel会监视所有select负责的socket，
    当任何一个socket中的数据准备就绪，select就会返回。这时进程再调用read操作(第二步)。
```
> 在处理更多连接数的时候,性能比较卓越;   
> 反之,在处理较少连接数时,延迟可能更大,不如异步I/O
2. 异步I/O
```
    进程发起I/O请求之后,直接去做其他的事情了。
    此时,kernel收到请求后,会立刻返回，不会对进程有任何的block，
    但它会等待数据准备完成，然后将数据拷贝到用户内存，当一切都做好了再返回进程一个singal
```
> 少了去查询IO状态的这部分,且在整个过程中是不加锁的

